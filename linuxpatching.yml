---
- hosts: all
  gather_facts: True


##variables from survey
  vars:
    create_snapshot: "{{ create_snapshot_survey|bool | default('True') }}"
    create_jira: "{{ create_jira_survey|bool | default('True') }}"
    
##Return codes to look for when checking service
    returncode:
      - 403
      - 200
      - 302
    
  
  module_defaults:
    jira:
      uri: "{{ jira_uri }}"
      username: "{{ jira_username }}"
      password: "{{ jira_password }}"
      validate_certs: False
      project: "{{ jira_project }}"
      timeout: 120
  
  pre_tasks:

  - name: "Create master JIRA issue"
    jira:
      operation: create
      issuetype: Task
      summary: Ansible automatic patching - master issue
    args:
      fields: "{{ jira_customfields }}"
    run_once: True
    delegate_to: localhost
    register: master_issue
    when: create_jira  
    

#Check if patch should be canceld
  - name: Look for JYSKPatchingLock
    command: find /tmp/ -name ".JYSKPatchingLock-{{ansible_date_time.month}}{{ansible_date_time.year}}"
    register: skip_update
    become: yes
    become_method: sudo

  - debug:
      msg: "{{ skip_update.stdout }}"
      verbosity: 2


  - name: Update master issue if update was canceled
    jira:
      operation: comment
      issue: "{{ master_issue.meta.key }}"
      comment: "Update canceled for {{ ansible_fqdn|lower | default('unresolved hostname') }} because of .JYSKPatchingLock-{{ansible_date_time.month}}{{ansible_date_time.year}} - skipping"
    delegate_to: localhost
    when: master_issue and skip_update.stdout | length > 0
    
  - name: Send slack message if update should be canceled
    slack:
      token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
      channel: "#ansibletest"
      msg: 'Patching of {{ ansible_hostname | lower }} canceled due to JYSKPatchingLock-{{ansible_date_time.month}}{{ansible_date_time.year}}'
    delegate_to: localhost
    when: master_issue and skip_update.stdout | length > 0
    
 
#Figure out if we need updating
  tasks:

  - name: Figure out if we need updating
    yum:
      list: updates
      update_cache: True
    register: needs_updating
    become: True
    tags: needs_updating
    when: ansible_distribution == "CentOS" or ansible_distribution == "OracleLinux" and not skip_update.stdout | length > 0

  - name: Print needs_updating
    debug:
      msg: "{{ needs_updating }}"
      verbosity: 2
    when: not skip_update.stdout | length > 0
    tags: needs_updating


#Start updating
  - name: Start the update process
    
    block:
    - name: Create JIRA issue
      jira:
        operation: create
        issuetype: Task
        summary: "Automatic patching on {{ ansible_fqdn|lower | default('unresolved hostname') }}"
      args:
        fields: "{{ jira_customfields }}"
      delegate_to: localhost
      register: issue
      when: create_jira

    - name: "Link issue to {{ master_issue.meta.key }}"
      jira:
        operation: link
        linktype: Relates
        inwardissue: "{{ issue.meta.key }}"
        outwardissue: "{{ master_issue.meta.key }}"
      delegate_to: localhost
      when: create_jira
    
    - name: Fetch list of installed packages
      yum:
        list: installed
      register: installed_packages
      when: create_jira

    - name: Update JIRA with information about installed packages
      jira:
        operation: comment
        issue: "{{ issue.meta.key }}"
        comment: |
          *Packages installed*
          ||arch||envra||name||release||repo||version||
          {% for r in installed_packages.results %}
          |{{ r.arch }}|{{ r.envra }}|{{ r.name }}|{{ r.release }}|{{ r.repo }}|{{ r.version }}|
          {% endfor %}
      delegate_to: localhost
      when: create_jira

    - name: Update JIRA with information about packagess to be updated
      jira:
        operation: comment
        issue: "{{ issue.meta.key }}"
        comment: |
          *Packages that will be updated*
          ||arch||envra||name||release||repo||version||
          {% for r in needs_updating.results %}
          |{{ r.arch }}|{{ r.envra }}|{{ r.name }}|{{ r.release }}|{{ r.repo }}|{{ r.version }}|
          {% endfor %}
      delegate_to: localhost
      when: create_jira
      tags: 
        - needs_updating
  
    - name: Take snapshot of virtual machine before updating
      vmware_guest_snapshot:
        datacenter: "JYSK"
        use_instance_uuid: True
        uuid: "{{ config.instanceuuid }}"
        state: present
        snapshot_name: "Ansible Patch Management"
        description: "Ansible Patch Management Snapshot {{ issue.meta.key }}"
        validate_certs: False
      delegate_to: localhost
      register: snapshot
      when: create_snapshot
      tags: snapshot
    
    - name: Print result of snapshot
      debug:
        msg: "{{ snapshot }}"
        verbosity: 2
    
    - name: Update JIRA with snapshot result
      jira:
        operation: comment
        issue: "{{ issue.meta.key }}"
        comment: |
          {% if snapshot.changed %}
          *Snapshot information*
          ||name||creation_time||description||
          {% for s in snapshot.snapshot_results.snapshots %}
          |{{ s.name }}|{{ s.creation_time }}|{{ s.description }}
          {% endfor %}
          {% else %}
          Snapshot not taken. Message was "{{ snapshot.msg }}""
          {% endif %}
      delegate_to: localhost
      when: create_jira and create_snapshot
      tags: 
        - snapshot
        - jira
      
    - name: Send slack message with link to Jira master issue
      slack:
        token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
        channel: "#ansibletest"
        msg: "Link to master issue jira.jysk.com/browse/{{ master_issue.meta.key }}"
      run_once: true
      delegate_to: localhost      

    - name: Update all packages to latest
      yum:
        name: '*'
        state: latest
        update_cache: True
        skip_broken: yes
      register: yum_update
      become: True

    - name: Print result of yum_udpate
      debug:
        msg: "{{ yum_update }}"
        verbosity: 2
    
    - name: Update issue with result of yum update
      jira:
        operation: comment
        issue: "{{ issue.meta.key }}"
        comment: |
          *Result of yum update*
          {code}
          {{ yum_update.results[0] }}
          {code}
      delegate_to: localhost
      when: create_jira

    - name: Find out if we need restarting
      shell: needs-restarting -r
      ignore_errors: True
      changed_when: False
      register: restart_required

    - name: Update with information about restart required
      jira:
        operation: comment
        issue: "{{ issue.meta.key }}"
        comment: |
          {% if restart_required.rc == 0 %}
          No reboot required
          {% else %}
          *Rebooting server*
          {code}
          {{ restart_required.stdout }}
          {code}
          {% endif %}
      delegate_to: localhost
      when: create_jira
      
    - name: Reboot if required
      reboot:
      when: restart_required.rc == 1
      become: True

##Check server and service is up and running after patching
    - name: Check server is available and service is running
      block: 
        ##Get every servers PrimaryService from VMware custom attribute
        - name: Gather Primary Service from VMware
          vmware_guest_info:
            validate_certs: False
            datacenter: JYSK
            name: "{{ config.name }}"
          register: vm
          delegate_to: localhost
         
        #- debug: 
        #    msg: "{{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService }}"
        #    verbosity: 2
        
        - name: Define Service name
          set_fact: 
            app_name: '{{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService.split(",") }}'
            verbosity: 2
       
        - name: Test server can be reached
          wait_for_connection:
            timeout: 30
          ignore_errors: yes
          register: server_respond
          
        - name: Send slack message if server is not reachable
          slack:
            token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
            channel: "#ansibletest"
            msg: | 
               Link to jira issue jira.jysk.com/browse/{{ issue.meta.key }}
               {{ansible_hostname| lower}} is not reachable
          delegate_to: localhost
          when: server_respond is failed

        - name: Ensure service is running
          service_facts:
          until: "ansible_facts.services[item +'.service'].state == 'running'"
          ignore_errors: yes
          loop: "{{ app_name }}"
          register: service_running
          become: yes
        
        #- debug: 
        #    msg: "{{ service_running }}"
        #    verbosity: 2
        #  
        
        - name: Send slack message if service is not running
          slack:
            token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
            channel: "#ansibletest"
            msg: | 
              {{ item.item }} not running
          loop: "{{ service_running.results }}"
          when: "item.ansible_facts.services[item.item +'.service'].state != 'running'"
          delegate_to: localhost
          
       # - name: Send slack message if service is not running
       #   slack:
       #     token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
       #     channel: "#ansibletest"
       #     msg: | 
       #       {{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService }} is not running on {{ ansible_hostname | lower }}
       #       Link to jira issue jira.jysk.com/browse/{{ issue.meta.key }}
       #   delegate_to: localhost
       #   
        - name: Ensure Service is responding 
          uri:
            url: "http://localhost:8080"
            status_code: "{{ returncode }}"
            use_proxy: False
          ignore_errors: yes
          loop: "{{ service_running.results }}"
          register: servicerespond
          when: "item.ansible_facts.services[item.item +'.service'].state == 'running'"
        
        - debug: 
            msg: "{{ servicerespond }}"
            verbosity: 2

        - name: Send slack message if service is not responding
          slack:
            token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
            channel: "#ansibletest"
            msg: | 
              {{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService|upper }} is not responding on {{ ansible_hostname | lower }}
              Link to jira issue jira.jysk.com/browse/{{ issue.meta.key }}
          delegate_to: localhost
          when: servicerespond is failed
          
        - name: Update jira with results from checking service
          jira:
            operation: comment
            issue: "{{ issue.meta.key }}"
            comment: |
              *Checking server after patch*
              {% if server_respond is succeeded and servicerespond.status == returncode and ansible_facts.services[app_name +'.service'].state == 'running' %}
              Everything is OK
              {% elif server_respond is succeeded and servicerespond.status != 'returncode' and ansible_facts.services[app_name +'.service'].state == 'running' %}
              Server: OK
              Service: {{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService }} is running, not responding
              {% elif server_respond is succeeded and servicerespond.status != 'returncode' and ansible_facts.services[app_name +'.service'].state != 'running' %}
              Server: OK
              Service: {{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService }} is down
              {% elif server_respond is failed and ansible_facts.services[app_name +'.service'].state != 'running' %}
              Server: {{ ansible_hostname }} is down
              Service: {{ vm.instance.customvalues.AnsiblePatchManagement_PrimaryService }} is down
              {% endif %}
          delegate_to: localhost
          when: create_jira and not servicerespond.status in returncode or server_respond is failed
          
        - name: Update jira with if snapshot is removed or not
          jira:
            operation: comment
            issue: "{{ issue.meta.key }}"
            comment: | 
              *Snapshot cleanup*
              {% if servicerespond.status == returncode %}
              Snapshot "Ansible Patch Management" is removed
              {% elif not servicerespond.status == returncode %}
              Snapshot "Ansible Patch Management" not removed
              {% endif %}
          args:
            warn: false
          delegate_to: localhost
          when: snapshot 
         
    # only execute the block above if needs_updating contains a result 
      when: skip_update.stdout | length == 0 and needs_updating.results|length > 0          
      

##Removing snapshot and closing jira issue will only happen if the check phase is OK
    - name: Remove patch snapshot from VMWare
      vmware_guest_snapshot:
        datacenter: "JYSK"
        use_instance_uuid: True
        uuid: "{{ config.instanceuuid }}"
        snapshot_name: "Ansible Patch Management"
        validate_certs: False
        state: absent
      delegate_to: localhost
      when: servicerespond.status in returncode

    - name: Send slack message if snapshot is not removed
      slack:
        token: TC160KSCC/B010WV9DH26/Sn4Yabw4VP0VGkj6ZL9nL3MM
        channel: "#ansibletest"
        msg: | 
          Snapshot of {{ ansible_hostname | lower }} is not removed because patch failed
          Link to jira issue jira.jysk.com/browse/{{ issue.meta.key }}
      delegate_to: localhost
      when: not servicerespond.status in returncode

    - name: "Close issue"
      jira:
        operation: transition
        status: Close
        issue: "{{ issue.meta.key }}"
      delegate_to: localhost
      when: create_jira and servicerespond.status in returncode

    # only execute the block above if needs_updating contains a result 
    when: skip_update.stdout | length == 0 and needs_updating.results|length > 0 


##Update jira with "no updates available" - will only be executed if no updates are found
  - name: Update master issue if no updates available for the server
    jira:
      operation: comment
      issue: "{{ master_issue.meta.key }}"
      comment: "No updates for {{ ansible_fqdn|lower | default('unresolved hostname') }} - skipping"
    delegate_to: localhost
    when: master_issue and needs_updating.results|length == 0 and not skip_update.stdout | length > 0
  
  post_tasks:
  
  - name: Update timestamp for last patch
    vmware_guest_custom_attributes:
      validate_certs: False
      datacenter: JYSK
      name: "{{ config.name }}"
      state: present
      attributes:
        - name: LastPatched
          value: "{{ ansible_date_time.date }}"
    delegate_to: localhost
    when: needs_updating.results|length != 0

  - name: "Close issue {{ master_issue.meta.key }} when all is done"
    jira:
      operation: transition
      status: Close
      issue: "{{ master_issue.meta.key }}"
    run_once: True
    delegate_to: localhost
    when: create_jira

  - name: "Print JIRA master issue key"
    debug:
      msg: |
        Master Issue {{ master_issue.meta.key }}
      verbosity: 2
    run_once: True
    delegate_to: localhost
    when: create_jira

  - name: "Print JIRA issue key"  
    debug:
      msg: |
        Issue {{ issue.meta.key | default('none')}}
      verbosity: 2
    delegate_to: localhost
    when: create_jira
    


